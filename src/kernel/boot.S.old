# Declare constants for the multiboot header.
.set ALIGN,    1<<0                     # align loaded modules on page boundaries
.set MEMINFO,  1<<1                     # provide memory map
.set VMODE,    1<<2                     # enable video
.set FLAGS,    ALIGN | MEMINFO | VMODE  # this is the Multiboot 'flag' field

.set MAGIC,    		0xE8525D6                # 'magic number' lets bootloader find the header (Note: This is the multiboot2 number v1 is 0x1BADB002)
.set ARCH,	   		0						 # architecture, 0=x86, 4=M
.set HEADER_LENGTH, header_start-header_end	 # header length in bytes
.set CHECKSUM, 		-(MAGIC + FLAGS + ARCH)  # checksum of above, to prove we are multiboot2

# Declare a multiboot header that marks the program as a kernel. These are magic values that are documented in the multiboot standard.
.section .multiboot_header
.align 8
header_start:
	.long MAGIC
	.long ARCH
	.long HEADER_LENGTH
	.long CHECKSUM

	.short 5 # Framebuffer
	.short 1 # Optional tag
	.long 20 # Length of tag
	.long 640 # Number of horizontal pixels
	.long 480 # Number of vertical pixels
	.long 32 # Bit depth

	.short 0 # End of tags
	.short 0
	.long 8 # Multiboot2 spec says to put an 8 here, but GRUB doesn't like it
header_end:

/* Setup the stack */
.section .bss
.align 16
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

/* Kernel entrypoint */
.section .text
.global _start
.type _start, @function
_start:
	/* Initialize the stack */
	mov $stack_top, %esp

	/* Start the kernel */
	call kernel_main

	/* Infinite loop */
	cli 	/* Disable interrupts */
1:	hlt 	/* Wait for the next interrupt to arrive */
	jmp 1b 	/* Loop to hlt */

/*
Set the size of the _start symbol to the current location '.' minus its start.
This is useful when debugging or when you implement call tracing.
*/
.size _start, . - _start
